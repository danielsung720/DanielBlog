title: 學習筆記-JS利用遞歸找出倒置後序一樣的數字
author: Daniel Sung Blog
tags: [JS, CODEWAR, KYU7]
categories: [學習筆記]
date: 2020-12-28 22:23:00
---
這篇的Title實在有夠難打的，簡單來說就是...找出數字
<!-- more -->
### 題目
Number is a palindrome if it is equal to the number with digits in reversed order. For example, 5, 44, 171, 4884 are palindromes, and 43, 194, 4773 are not.

Write a function which takes a positive integer and returns the number of special steps needed to obtain a palindrome. The special step is: "reverse the digits, and add to the original number". If the resulting number is not a palindrome, repeat the procedure with the sum until the resulting number is a palindrome.

If the input number is already a palindrome, the number of steps is 0.

All inputs are guaranteed to have a final palindrome which does not overflow MAX_SAFE_INTEGER.

Example
For example, start with 87:
```javascript
  87 +   78 =  165     - step 1, not a palindrome
 165 +  561 =  726     - step 2, not a palindrome
 726 +  627 = 1353     - step 3, not a palindrome
1353 + 3531 = 4884     - step 4, palindrome!
```
4884 is a palindrome and we needed 4 steps to obtain it, so answer for 87 is 4.

簡單來說，就是把自己倒置後，看看序是不是一樣
如果不是的話，就把倒置後的自己相加，在看是不是一樣
看一共加了幾次，就return那個次數~

### 解答
#### My Answer
看看這多精美的判斷式...
```javascript
var palindromeChainLength = function(n) {
  // 字串反轉+轉數字
  var n2 = n.toString().split("").reverse().join("") * 1;
  
  // 初次判斷
  if(n2 == n){
    return 0;
  }else{
    // 計數器
    var i = 1;
    // 找到倒置序相同的數為止
    while(flag){
      // 相加
      var n3 = n + n2;
      // 倒置後轉數字
      var n4 = n3.toString().split("").reverse().join("") * 1;
      // 判斷
      if(n3 == n4){
        return i;
      }else{
        // 若不等就將本次的數放置到下個迴圈，並將計數器+1
        n = n3;
        n2 = n4;
        i++;
      }
    }
  }
};
```

#### Best Practices
```javascript
var palindromeChainLength  = function(n) {
  // 人家的倒置+轉型就是長得比我的漂亮=_=  
  var x = parseInt((n.toString()).split('').reverse().join(''));

  // 若不相等，就呼叫自己進入遞歸，直到x==n時，return的和就會是答案了
  if(n != x){
    return 1 + palindromeChainLength (n + x);
  }
  return 0;
};
```

### 解析
對，直面程式真的就是看不懂最佳解在return什麼東西，傻爆眼༼ つ ◕_◕ ༽つ
```javascript
// 展開運算子
var n = 87;
palindromeChainLength(87)                // 第一次 87
  palindromeChainLength(165 + 561)       // 第二次 726
    palindromeChainLength(726 + 627)     // 第三次 1353
      palindromeChainLength(1353 + 3531) // 第四次 4884
        palindromeChainLength()          // 第五次 x==n
        // 湖中女神的倒影
        return 0
      return 1 + 0
    return 1 + 1
  return 1 + 2
return 1 + 3

// 所以答案是4
```

## 總結
網路上對於遞迴的評價不是很好，容易產生堆疊溢位[(stack overflow)](.https://zh.wikipedia.org/wiki/%E5%A0%86%E7%96%8A%E6%BA%A2%E4%BD%8D)，所以非必要不太會去使用
所以看起來雖然很簡潔專業，但並沒有比較快且節省記憶體

但有一種叫做尾遞歸的優化方式(tail-recursive)，這個課題暫時先留給未來的自己吧XD